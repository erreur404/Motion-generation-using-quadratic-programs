# load typekits
import("eigen_typekit")
import("kdl_typekit")
import("rst-rt_typekit")

# load transport plugins
#import("rtt_rsbcomm")

# import component libs
import("rtt_gazebo_embedded")
import("rtt-gazebo-robot-sim")
import("rtt-core-extensions")
import("ProjectedDynamics")
import("CosimaUtilities")

require("os")
require("print")

var int DOFsize = 7;
var string model_name = "";
var string path_model_urdf = "";
var string path_model_srdf = "";
if (DOFsize == 7) then {
  model_name = "model://kuka-lwr-4plus";
  path_model_urdf = os.getenv("GAZEBO_MODEL_PATH")+"/kuka-lwr-4plus/model.urdf";
  path_model_srdf = os.getenv("GAZEBO_MODEL_PATH")+"/kuka-lwr-4plus/model.srdf";
} else {
  model_name = "model://kuka-artificial11DOF";
  path_model_urdf = os.getenv("GAZEBO_MODEL_PATH")+"/kuka-artificial11DOF/model.urdf";
  path_model_srdf = os.getenv("GAZEBO_MODEL_PATH")+"/kuka-artificial11DOF/model.srdf";
}

# instantiate components

# gazebo
loadComponent("gazebo","RTTGazeboEmbedded")
setActivity("gazebo",0,10,ORO_SCHED_OTHER)
gazebo.argv = strings("--verbose")
gazebo.add_plugin("libRTTGazeboClockPlugin.so")

# robot sim
loadComponent("robot_gazebo","cogimon::robotSim")
setActivity("robot_gazebo",0,11,ORO_SCHED_OTHER)

# load simulation related parts (i.e. models)

# actually start the gzserver
gazebo.configure()
# start the simulation process
gazebo.start()
# disable the dynamics
gazebo.toggleDynamicsSimulation(false)
# load model
gazebo.spawn_model("robotmodel", model_name, 10)


# configure components

# configure robot sim
# attach previously loaded model
robot_gazebo.getModel("robotmodel")

#load kinematic chains
robot_gazebo.loadURDFAndSRDF(path_model_urdf, path_model_srdf)

# execute the simulation bridge
robot_gazebo.configure()

# configure kin. chain view
robot_gazebo.setControlMode("full_arm", "JointTorqueCtrl")

# enable physics simulation again
gazebo.toggleDynamicsSimulation(true)

#   Compute forward dynamics for all links
var array jointsFkin = (0)*DOFsize
for (var int i = 0; i < DOFsize; i = i + 1 ) {
      jointsFkin[i] = i
      loadComponent("fkin"+i, "WrapperKDL")
      setActivity("fkin"+i,0.01,10,ORO_SCHED_OTHER)
      eval("fkin"+i+".loadModel(path_model_urdf, \"lwr_arm_base_link\",\"lwr_arm_"+i+"_link)")
      eval("fkin"+i+".setDOFsize(i)")
      eval("fkin"+i+".configure()")
}

loadComponent("fkin", "WrapperKDL")
setActivity("fkin",0.01,10,ORO_SCHED_OTHER)
fkin.loadModel(path_model_urdf, "lwr_arm_base_link","lwr_arm_7_link")
fkin.setDOFsize(DOFsize);
fkin.configure()



# LETS PLAY HERE !!

# for debug : generates a trajectory
loadComponent("trajectorygenerator", "TrajectoryGenerator")
setActivity("trajectorygenerator",0.01,10,ORO_SCHED_OTHER)
#trajectorygenerator.setTranslationOnly(translationOnly);
trajectorygenerator.setCenter(0.6,0.0,0.7)
trajectorygenerator.radius = 0.1
trajectorygenerator.timescale = 1.0;
trajectorygenerator.setWaitTime(10)
trajectorygenerator.preparePorts()
trajectorygenerator.configure()


# for debug : generates points to follow the trajectory
#loadComponent("positioncontroller", "PositionController")
#setActivity("positioncontroller",0.01,10,ORO_SCHED_OTHER)
#positioncontroller.setTranslationOnly(translationOnly);
#positioncontroller.setDOFsize(DOFsize);
#positioncontroller.addTSgravitycompensation(true);
#positioncontroller.setTaskSpaceDimension(TaskSpaceDimension);
#positioncontroller.setGains(200,10);
#positioncontroller.setGainsOrientation(450,10);
#positioncontroller.preparePorts();
#positioncontroller.configure();

import("MotionGenerationQuadraticProgram")
# you can do displayComponentTypes

loadComponent("myTorqueController", "MotionGenerationQuadraticProgram")
setActivity("myTorqueController", 0.05, 50, ORO_SCHED_OTHER)

myTorqueController.setDOFsize(DOFsize)

var ConnPolicy cp
# send joint status to the controller
connect("robot_gazebo.full_arm_JointFeedback", "myTorqueController.in_robotstatus_port", cp)
# send joint status to KDL for Jacobian computing

connect("robot_gazebo.full_arm_JointFeedback", "fkin.in_robotstatus_port", cp)
connect("fkin.out_jacobianTranslation_port", "myTorqueController.in_jacobian_port", cp)
connect("fkin.out_jacobianDotTranslation_port", "myTorqueController.in_jacobianDot_port", cp)
connect("fkin.out_cartPosTranslation_port", "myTorqueController.in_currentTaskSpacePosition_port", cp)
connect("fkin.out_cartVelTranslation_port", "myTorqueController.in_currentTaskSpaceVelocity_port", cp)
connect("fkin.out_robotstatus_port", "myTorqueController.in_robotstatus_port", cp)
connect("fkin.out_coriolisAndGravity_port", "myTorqueController.in_h_port", cp)
connect("fkin.out_inertia_port", "myTorqueController.in_inertia_port", cp)
connect("trajectorygenerator.out_desiredTaskSpacePosition_port", "myTorqueController.in_desiredTaskSpacePosition_port", cp)
connect("trajectorygenerator.out_desiredTaskSpaceVelocity_port", "myTorqueController.in_desiredTaskSpaceVelocity_port", cp)
connect("trajectorygenerator.out_desiredTaskSpaceAcceleration_port", "myTorqueController.in_desiredTaskSpaceAcceleration_port", cp)

# send commands to the robot
connect("myTorqueController.out_torques_port", "robot_gazebo.full_arm_JointTorqueCtrl", cp)

fkin.start()
trajectorygenerator.start()
myTorqueController.configure()
myTorqueController.start()

#generate graph file
import("rtt_dot_service")
loadService("this", "dot")
dot.generate

#loadService("this","scripting")
#scripting.runScript("logData.ops")
