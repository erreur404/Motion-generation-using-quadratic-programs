# load typekits
import("eigen_typekit")
import("kdl_typekit")
import("rst-rt_typekit")

# load transport plugins
#import("rtt_rsbcomm")

# import component libs
import("rtt_gazebo_embedded")
import("rtt-gazebo-robot-sim")
import("rtt-core-extensions")
import("ProjectedDynamics")
import("CosimaUtilities")

require("os")
require("print")

var int DOFsize = 7;
var string model_name = "";
var string path_model_urdf = "";
var string path_model_srdf = "";
if (DOFsize == 7) then {
  model_name = "model://kuka-lwr-4plus";
  path_model_urdf = os.getenv("GAZEBO_MODEL_PATH")+"/kuka-lwr-4plus/model.urdf";
  path_model_srdf = os.getenv("GAZEBO_MODEL_PATH")+"/kuka-lwr-4plus/model.srdf";
} else {
  model_name = "model://kuka-artificial11DOF";
  path_model_urdf = os.getenv("GAZEBO_MODEL_PATH")+"/kuka-artificial11DOF/model.urdf";
  path_model_srdf = os.getenv("GAZEBO_MODEL_PATH")+"/kuka-artificial11DOF/model.srdf";
}

# instantiate components

# gazebo
loadComponent("gazebo","RTTGazeboEmbedded")
setActivity("gazebo",0,10,ORO_SCHED_OTHER)
gazebo.argv = strings("--verbose")
gazebo.add_plugin("libRTTGazeboClockPlugin.so")


# robot sim
loadComponent("robot_gazebo","cogimon::robotSim")
setActivity("robot_gazebo",0,11,ORO_SCHED_OTHER)


# load simulation related parts (i.e. models)

# actually start the gzserver
gazebo.configure()
# start the simulation process
gazebo.start()
# disable the dynamics
gazebo.toggleDynamicsSimulation(false)
# load model
gazebo.spawn_model("robotmodel", model_name, 10)

# configure components

# configure robot sim
# attach previously loaded model
robot_gazebo.getModel("robotmodel")

#load kinematic chains
robot_gazebo.loadURDFAndSRDF(path_model_urdf, path_model_srdf)

# execute the simulation bridge
robot_gazebo.configure()

# configure kin. chain view
robot_gazebo.setControlMode("full_arm", "JointTorqueCtrl")

# enable physics simulation again
gazebo.toggleDynamicsSimulation(true)


print.ln("");
print.ln("");
print.ln("");
print.ln("<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<< forward kinematic modules initialisation");
print.ln("");
print.ln("");
print.ln("");
#   Compute forward dynamics for all links
if (DOFsize == 7) then {

        for (var int i = 1; i <= DOFsize; i = i + 1 ) {
              loadComponent("fkin"+i, "WrapperKDL");
              setActivity("fkin"+i,0.01,10,ORO_SCHED_OTHER);
              eval("fkin"+i+".loadModel(\""+path_model_urdf+"\", \"lwr_arm_base_link\",\"lwr_arm_"+i+"_link\")");

              eval("fkin"+i+".setDOFsize("+i+")");
              eval("fkin"+i+".configure()");
        }


} else {
        loadComponent("fkin"+i, "WrapperKDL");
        setActivity("fkin"+i,0.01,10,ORO_SCHED_OTHER);
        eval("fkin"+i+".loadModel(\""+path_model_urdf+"\", \"lwr_arm_base_link\",\"lwr_arm_"+i+"_link\")");

        eval("fkin"+i+".setDOFsize("+i+")");
        eval("fkin"+i+".configure()");

        loadComponent("fkin"+i, "WrapperKDL");
        setActivity("fkin"+i,0.01,10,ORO_SCHED_OTHER);
        eval("fkin"+i+".loadModel(\""+path_model_urdf+"\", \"lwr_arm_base_link\",\"lwr_arm_"+i+"_link\")");

        eval("fkin"+i+".setDOFsize("+i+")");
        eval("fkin"+i+".configure()");
}
print.ln("");
print.ln("");
print.ln("");
print.ln(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>> forward kinematic modules initialisation");
print.ln("");
print.ln("");
print.ln("");

#loadComponent("fkin", "WrapperKDL")
#setActivity("fkin",0.01,10,ORO_SCHED_OTHER)
#fkin.loadModel(path_model_urdf, "lwr_arm_base_link","lwr_arm_7_link")
#fkin.setDOFsize(DOFsize);
#fkin.configure()



# LETS PLAY HERE !!

# for debug : generates a trajectory
loadComponent("trajectorygenerator", "TrajectoryGenerator");
setActivity("trajectorygenerator",0.01,10,ORO_SCHED_OTHER);
#trajectorygenerator.setTranslationOnly(translationOnly);
trajectorygenerator.setCenter(0.6,0.0,0.7)
trajectorygenerator.radius = 0.1
trajectorygenerator.timescale = 1.0;
trajectorygenerator.setWaitTime(10)
trajectorygenerator.preparePorts()
trajectorygenerator.configure()

loadComponent("trajectorygenerator2", "TrajectoryGenerator");
setActivity("trajectorygenerator2",0.01,10,ORO_SCHED_OTHER);
trajectorygenerator2.setCenter(1.6,0.0,1.7)
trajectorygenerator2.radius = 0.2
trajectorygenerator2.timescale = 2.0;
trajectorygenerator2.setWaitTime(10)
trajectorygenerator2.preparePorts()
trajectorygenerator2.configure()


# for debug : generates points to follow the trajectory
#loadComponent("positioncontroller", "PositionController")
#setActivity("positioncontroller",0.01,10,ORO_SCHED_OTHER)
#positioncontroller.setTranslationOnly(translationOnly);
#positioncontroller.setDOFsize(DOFsize);
#positioncontroller.addTSgravitycompensation(true);
#positioncontroller.setTaskSpaceDimension(TaskSpaceDimension);
#positioncontroller.setGains(200,10);
#positioncontroller.setGainsOrientation(450,10);
#positioncontroller.preparePorts();
#positioncontroller.configure();

import("MotionGenerationQuadraticProgram")
# you can do displayComponentTypes

loadComponent("myTorqueController", "MotionGenerationQuadraticProgram");
setActivity("myTorqueController", 0.05, 50, ORO_SCHED_OTHER);
myTorqueController.setDOFsize(DOFsize);
myTorqueController.setTorqueLimits(array(100, DOFsize), array(-100, DOFsize))
myTorqueController.setAccelerationLimits(array(100, DOFsize), array(-100, DOFsize))

var ConnPolicy cp
# send joint status to the controller
connect("robot_gazebo.full_arm_JointFeedback", "myTorqueController.in_robotstatus_port", cp)
# send joint status to KDL for Jacobian computing

for (var int j = 1; j <= DOFsize; j = j + 1 )
{
  connect("robot_gazebo.full_arm_JointFeedback", "fkin"+j+".in_robotstatus_port", cp)
}

var int n = DOFsize;

connect("fkin"+n+".out_robotstatus_port", "myTorqueController.in_robotstatus_port", cp);
connect("fkin"+n+".out_coriolisAndGravity_port", "myTorqueController.in_h_port", cp);
connect("fkin"+n+".out_inertia_port", "myTorqueController.in_inertia_port", cp);

n = DOFsize;

connect("fkin"+n+".out_jacobianTranslation_port", "myTorqueController.in_jacobian_port_"+n, cp);
connect("fkin"+n+".out_jacobianDotTranslation_port", "myTorqueController.in_jacobianDot_port_"+n, cp);
connect("fkin"+n+".out_cartPosTranslation_port", "myTorqueController.in_currentTaskSpacePosition_port_"+n, cp);
connect("fkin"+n+".out_cartVelTranslation_port", "myTorqueController.in_currentTaskSpaceVelocity_port_"+n, cp);
connect("trajectorygenerator2.out_desiredTaskSpacePosition_port", "myTorqueController.in_desiredTaskSpacePosition_port_"+n, cp);
connect("trajectorygenerator2.out_desiredTaskSpaceVelocity_port", "myTorqueController.in_desiredTaskSpaceVelocity_port_"+n, cp);
connect("trajectorygenerator2.out_desiredTaskSpaceAcceleration_port", "myTorqueController.in_desiredTaskSpaceAcceleration_port_"+n, cp);

#n = 5;

#connect("fkin"+n+".out_jacobianTranslation_port", "myTorqueController.in_jacobian_port_"+n, cp);
#connect("fkin"+n+".out_jacobianDotTranslation_port", "myTorqueController.in_jacobianDot_port_"+n, cp);
#connect("fkin"+n+".out_cartPosTranslation_port", "myTorqueController.in_currentTaskSpacePosition_port_"+n, cp);
#connect("fkin"+n+".out_cartVelTranslation_port", "myTorqueController.in_currentTaskSpaceVelocity_port_"+n, cp);
#connect("trajectorygenerator.out_desiredTaskSpacePosition_port", "myTorqueController.in_desiredTaskSpacePosition_port_"+n, cp);
#connect("trajectorygenerator.out_desiredTaskSpaceVelocity_port", "myTorqueController.in_desiredTaskSpaceVelocity_port_"+n, cp);
#connect("trajectorygenerator.out_desiredTaskSpaceAcceleration_port", "myTorqueController.in_desiredTaskSpaceAcceleration_port_"+n, cp);

# send commands to the robot
connect("myTorqueController.out_torques_port", "robot_gazebo.full_arm_JointTorqueCtrl", cp)

for (var int k = 1; k <= DOFsize; k = k + 1 )
{
  eval("fkin"+k+".start()");
}
trajectorygenerator.start()
trajectorygenerator2.start()
myTorqueController.configure()
myTorqueController.start()

#generate graph file
import("rtt_dot_service")
loadService("this", "dot")
dot.generate

#loadService("this","scripting")
#scripting.runScript("logData.ops")
